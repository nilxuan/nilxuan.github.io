+++
title = 'KMP 字符串匹配算法'
date = 2024-05-09T17:01:25+08:00
draft = false
summary = 'KMP 字符串匹配算法'
keywords = ["KMP","字符串匹配"]
tags =["KMP","字符串匹配","算法"]
+++

KMP 是由一种高效的字符串匹配算法。字符串匹配问题是指，给定字符串`s` 和 `t`，确定 `t` 在 `s` 中首次出现的位置，如果 `s` 中找不到 `t`，那么返回 -1；
# 朴素的字符串匹配算法
在字符串匹配问题中，是想要找到这样一个 `s` 中的下标  `i`，使得 `s` 从  `i` 开始的子串与 `t` 相同；一种直观的处理方法是双重循环，逐个检查子串：
## 实现
```go
func NormalSearch(s, t string) int {
    for i := 0; i <= len(s)-len(t); i++ {
        j := 0
        
        for ; j < len(t); j++ {
            if s[i+j] != t[j] {
                break
            }
        }

        if j == len(t) {
            return i
        }
    }

    return -1
}
```

## 分析
双重循环的思路中，外层循环检查 `s` 的每一个位置 `i` ，然后在内层循环中看以 `i` 开始的子串是否和 `t` 是匹配的；如果发现子串对应位置上的字符不匹配，那么就结束内层循环，然后在外层循环中自增 `i`，即相当于将检查点向前移动一步，然后再次进入内循环，内循环又从 0 开始匹配 `t` 新的子串；

## 问题
朴素字符串匹配算法的问题在于，每一次进入内层循环的时候，都是从 0 开始尝试匹配，即 `j := 0`；这部分匹配并没有充分利用匹配过程中获得信息，从而需要做一些无用的匹配；
考虑匹配过程中出现的这种情况：以 `i` 开始的子串和 `t` 部分匹配。记 `s` 的子串为 s\[x, y\]，记 `t` 的这匹配部分为t\[0,y-x+1\]，也就是说 s\[y+1\] 与 t\[y-x+2\]并不匹配：

![20240509154258](/images/20240509154258.png)

记 `t` 的长度为 m，按照朴素的字符串匹配算法，接下来将尝试进行 s\[x+1, m+x\] 和 t\[0, m-1\]的匹配；
问题就在于这部分匹配没有利用 **s\[x, y\] 和 t\[0,y-x+1\] 是匹配的**这一重要信息。 
s\[x+1, m+x \] 和 t\[0, m-1\] 匹配，可以看作是  s\[x+1, y\] 和 t\[0, y-x-1\] 的匹配以及 s\[y+1, m+x\] 和 t\[y-x, m-1\]；
重点关注 s\[x+1, y\] 和 t\[0, y-x-1\]的匹配。考虑到 **s\[x, y\] 和 t\[0,y-x+1\]是匹配的**，所以s\[x+1, y\] 和 t\[0, y-x-1\]的匹配过程相当于：

![20240509162240](/images/20240509162240.png)

这个匹配实际上是字符串 `t` 的某一个前缀字符串之间的匹配。由于在匹配过程中，这种部分匹配的情况可能会多次出现，如果能有一种办法可以记录这种匹配信息，从而在后续的匹配中能够利用这些信息来避免不必要的、重复的比较，那么就可以提到匹配效率；
而 KMP 算法给出了一种解决方案；
# KMP 算法
首先需要引入一个“真后缀”的概念。如果字符串 `X = YZ`，那么 `Z` 称为 `X` 的后缀，当 `Y` 不为空的时候，`Z` 称为 `X` 的真后缀；如果同时满足 `X=ZP`，即 `Z` 也是 `X` 的一个前缀，那么 `Z` 就称为 `X` 的特殊真前缀；
KMP 的核心思想是：
1. 预处理待查找字符串 `T`，得到一个数组 `M`。其中 `M\[i\] = k`，表示字符串 `T[0,i]` 的最长的特殊真前缀的长度；
2. 匹配过程中通过数组`M`，跳过中间不必要的匹配检查；

## 理解
以下图为例：

![20240509162240](/images/20240509162240.png)

由于字符串 `s` 中的字符 `e` 和字符串 `t` 中的字符 `g` 不匹配，在朴素字符串匹配算法中，接下来的匹配的过程将是字符 `b` 和 字符 `a` 进行匹配。
而 KMP 算法中由于得到了数组 `M`，所以我们知道字符 `f` 的下标为 5，而 M\[5\]，即字符串 `abcdef` 的特殊真后缀的长度为 0（先目测一下）；这意味着上图所表示的朴素字符串匹配算法在接下来的匹配是没有必要的，因为特殊真后缀实际上就表示了一种匹配：字符串的一个长度为 `X` 的真后缀与字符串的长度为 `X` 的前缀是匹配的；
所以，KMP 算法的核心也有两个：
1. 最长特殊真后缀长度的计算——数组 `M` 的计算；
2. 匹配——数组 `M` 的使用；

## 实现
这里一共会提供两种 KMP 算法的 go 语言实现。
首先是根据《算法导论（第三版）》中关于 KMP 算法的伪代码而实现的代码，希望从字符串 `t` 中检索字符串 `p` 首次出现的位置：
```go
func KMP(t, p string) int {
    n, m := len(t), len(p)
    
    k := getPrefix(p)
    
    q := 0
    
    for i := 0; i < n; i++ {
        for q > 0 && p[q] != t[i] {
            q = k[q-1]
        }

        if p[q] == t[i] {
            q++
        }

        if q == m {
            return i - m + 1
        }
    }
    
    return -1
}

func getPrefix(s string) map[int]int {
    r := make(map[int]int)
    m := len(s)

    r[0] = 0
    k := 0

    for q := 1; q < m; q++ {
        for k > 0 && s[q] != s[k] {
            k = r[k-1]
        }

        if s[q] == s[k] {
            k++
        }
        
        r[q] = k
    }

    return r
}
```

第二种代码实现是自己根据对算法核心思想的理解而实现的，从字符串 `s` 中寻找字符串 `t` 首次出现的位置：
```go
func findSubString(s string, t string) int {
    move := getMoveInfo(t)
    
    k := 0
    
    for i := 0; i < len(s); i++ {
        for i < len(s) && k < len(t) && s[i] == t[k] {
            i++
            k++
        }

        if k == len(t) {
            // 找到了子串
            return i - len(t)
        }

        if i == len(s) {
            // 找遍了s，也没找到
            return -1
        }

        // 还能继续找
        if k-1 >= 0 {
            k = move[k-1] // k-1 下标对应的子串长度，即是下一次对比的索引
            i--           // 因为后续还有 i++ 这里先回退，即保证 i 不变
        }
    }

    return -1
}

func getMoveInfo(s string) map[int]int {
    r := make(map[int]int)
    r[0] = 0
    
    p := 0
    for i := 1; i < len(s); i++ {
        for (i < len(s) && p < len(s)) && (s[i] == s[p]) {
            p++
            r[i] = p
            i++
        }

        if i == len(s) {
            // 计算完毕
            break
        }

        if p == 0 {
            r[i] = 0
        } else {
            p = r[p-1]
            i--
        }
    }
    
    return r
}
```

## 分析
这里也分数组计算、匹配这两个步骤进行两种算法实现的对比。
### 位移数组计算
《算法导论》中的计算思路是：
1. 如果出现部分匹配，则用位移数组更新已经匹配的数字 k；
2. 结束循环有两种情况：
	1. 该位置的字符是匹配，所以已经匹配数需要自增；
	2. 此时没有匹配数了，即 k 等于 0，此时不需要自增匹配数；
3. 不论 2 中是哪一种情况，此时都得到了特殊真后缀的长度——k，因此将其记录；

自己实现的思路是：
1. 只要出现字符匹配，那么就执行：
	1. 移动两个指针；
	2. 匹配数自增；
	3. 记录数据；
2. 结束循环有三种情况：
	1. 所有位置均已经处理完了，所以退出计算即可；
	2. 出现了不匹配：
		1. 如果匹配数不为 0，那么就需要更新匹配数，继续外层循环；
		2. 如果匹配数为 0，那么该记录数据；

这里两种思路是截然不同的：

《算法导论》中的目的很明确：找到特殊真后缀的长度，然后将其记录下来；

自己实现的过程，实际上是对比较过程的“翻译”：匹配——那么移动指针，不匹配——那么判断是结束计算还是更新长度后继续匹配；
毫无疑问，《算法导论》伪代码实现逻辑更为精炼；自己实现的代码中，if 判断的圈层复杂度太高。

### 匹配过程
《算法导论》中的逻辑是：
1. 如果出现部分匹配，则用位移数组更新已经匹配的数字 k；
2. 结束循环有两种可能：
	1. 对应位置是匹配的，此时更新匹配的字符数；如果等于目标字符串长度，那么返回位置即可；
	2. 如果已经没有匹配数了，那么就前移指针 i，开始下一轮匹配；

自己实现的计算逻辑是：

1. 只要匹配并且没有遍历完字符串，那么就前移指针；
2. 结束循环时：
	1. 如果遍历完毕了目标字符串，那么就说明找到了；
	2. 如果遍历完了待检查字符串，那么说明一定找不到了；
	3. 此时就只剩出现了不匹配，这个时候就更新匹配数，进行下一轮匹配；

这里两种思路也是截然不同的：

《算法道路》中的匹配思路是：如果不匹配，那么移动待匹配的字符串；如果匹配，那么更新已匹配数，然后继续检查；

自己实现的过程，是只要匹配，那么就移动指针；如果不匹配，那么移动待匹配的字符串，继续下次检查；
可以看到，《算法导论》伪代码实现逻辑更为精炼，自己实现的代码中，if 判断次数有点多；

### 总结
整体来看，两种实现代码里，风格都是统一的：
1. 《算法导论》中 KMP 算法的实现重心在于不匹配时的动作。
2. 自己实现的代码的重心在于匹配时的动作；
## 反思
从代码的逻辑、整洁度上看，自己实现的代码和《算法导论》中的伪代码都有不少的差距；、
前者更像是对匹配过程的翻译，后者是对单次匹配动作的翻译；前者逻辑显得比较笨重，后者更加精炼；
同一种算法思路，会有不同的算法实现，也会有质量和复杂度上的区别，这是因为解决问题的步骤是不同的；
如何从计算机的角度思考问题而不是人的角度思考问题，是一个值得思考的问题；
